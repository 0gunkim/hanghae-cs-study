# 026 고수준 언어에서 프로그램 실행까지

<hr>

## 프로그래밍 언어의 스펙트럼

> 추상화의 정도로 프로그래밍 언어를 분류함

`추상화` : 몰라도 되는 내용은 숨기고 꼭 알아야 할 내용만 드러내는 것  
`저수준 언어` : 컴퓨터에 친화적인 언어/ 정밀한 문법 요구/ 작성하기 어렵고 유지보수가 불편  
`고수준 언어` : 인간에 친화적인 언어/맥락에 따라 많은 부분 생략/ 작성하기 쉽고 유지보수가 쉬움  

<hr>

### 기계어 (1세대)
: 전기적 신호의 유(1) 무(0) 로 구성되어 CPU가 해독할 수 있는 언어.  
> 제조사별로 지정한 CPU에서 사용할 수 있는 명령어 집합을 따라야 하기 때문에  
> 같은 신호여도 CPU에 따라 다르게 해독될 수 있다.

### 어셈블리어 (2세대)
: 기계어와 일대일 대응 되어 쓰여진 언어.
> 일대일 대응이므로 기계어와 마찬가지로 CPU마다 다르다.

`어셈블러` : 어셈블리어를 기계어 형태의 코드로 해석해주는 프로그램

### 고급 언어 (3세대)
: 컴퓨터의 언어 형식과 무관하게 자연어와 유사한 구성을 띄는 언어.

#### + 자연어
: 우리가 일상 생활에서 사용하는 언어

`컴파일링` : 고수준 언어를 저수준 언어로 변환하는 과정 

<hr>

`프로그램` : 컴퓨터에게 정해진 일을 시키는 설명서  
`프로그래밍 언어` : 컴퓨터에게 임무를 지시하기 위한 특정 체계의 언어  

<hr>

## 프로그래밍 언어 분류

1. 객체 지향 지원 여부 (절차 지향 -> 객체 지향) 
2. 변수의 자료형 지정 여부 (Static Typing / Dynamic Typing)

![image](https://user-images.githubusercontent.com/106153814/183239057-d9b5ce9e-0e9c-4ae0-9e9f-b298adbc2b16.png)

<hr>

## 절차 지향 프로그래밍 (Procedural Programming)

> 프로그램을 기능 중심으로 바라봄. `무엇을 어떤 절차로 할 것인가?` -> 순서

`Top down` : 하향식. 프로그램 전체가 유기적으로 연결되어 있어야 하고, 순차적으로 처리하는 방식.

- 장점 : 코드가 정연하며, 이해하기 쉽다. 컴퓨터의 처리구조와 유사해 실행 속도가 빠르다.  
- 단점 : 코드 완성까지 실행해보기 어렵다. 만약 오류가 있다면 처음부터 뜯어 고쳐야 할 수 있다. 
 실행 순서가 정해져 있어 코드 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

> 단점을 보완하기 위해 객체지향 개념 등장

<hr>

## 객체 지향 프로그래밍 (Object-Oriented Programming)

> 기능이 아닌 객체가 중심이 됨. `누가 어떤 일을 할 것인가?` -> 역할

`Bottom up` : 상향식. 필요 세부 기능을 설계하고, 이들끼리 상호작용 하는 방식.

- 장점 : 코드의 재활용성이 높고 디버깅이 간편하다. 일부 기능만 테스트 해볼 수 있다.  
데이터나 기능에 변화가 생겨도 관련 객체만 신경쓰면 되기 때문에 프로그래밍 하기 수월하다.  
- 단점 : PP에 비해 처리 속도가 느리다. 설계가 어렵다.

|특징|설명|
|:--|:--|
|추상화|객체들의 공통 특징을 도출해 필요하지 않은 부분 제거|
|캡슐화|데이터와 알고리즘을 묶어 외부에 정보 은닉|
|상속성|상위 클래스의 특징을 하위 클래스가 이어받음|
|다형성|명령 해석을 객체에 의존 - 오버라이딩 / 오버로딩|

> 오버라이딩 :부모클래스의 메소드와 같은 이름을 사용하며 매개변수도 같되 내부 소스를 재정의  
> 오버로딩 :같은 이름의 함수를 매개변수를 다르게 하여 경우에 따라 호출하여 사용

![image](https://user-images.githubusercontent.com/106153814/183239855-fddc6a98-7aa0-4abf-9347-ed55b7f43415.png)

<hr>

## Static typing & Dynamic typing

####  Static typing
: 변수의 자료형을 미리 지정하는 언어
> 명확성 추구 / 제약이나 규칙이 많음

#### Dynamic typing
: 실행될 때 변수의 자료형을 정해주는 언어
> 간결함과 편리함 추구

<hr>

단점을 보완하고자 등장했다고 해도 무조건적으로 우수하다고 할 수는 없다.  
구조와 특징이 명확히 다르기에 우수성은 개발자의 언어 활용 능력에 좌우된다.  

<hr>


참고자료

[tistory - 프로그래밍 언어 이해하기 1](https://j-a-lee.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B0%9C%EB%A1%A0-02-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

[tistory - 프로그래밍 언어 이해하기 2](https://j-a-lee.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B0%9C%EB%A1%A0-02-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2)

[tistory - 프로그래밍과 고수준, 저수준 언어](https://fickly.tistory.com/63)

[velog - 객체 지향 프로그래밍](https://velog.io/@in63119/TIL%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DObject-Oriented-Programming-OOP)

[naver blog - 절차지향언어 vs 객체지향언어](https://blog.naver.com/PostView.naver?blogId=gitacademy01&logNo=222394033958&redirect=Dlog&widgetTypeCall=true&directAccess=false)

